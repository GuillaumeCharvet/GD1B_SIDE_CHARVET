<!doctype html> 
<html lang="fr"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.CANVAS,
    width: 1280,
    height: 720,
    physics: {
        default: 'arcade',
        arcade: {
            //gravity: { y: 300 },
            debug: true
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    input:{gamepad:true}
};

var style = { font: "40px Arial", fill: "#52bace", align: "center" };
var cd_helpText = 60;

var cursors;

var gamepad;

var gamepadA;
var gamepadL;
var gamepadR;

var gameOver = false;

// PLAYER
var player;
var hp_player = 100;
var x_0 = 1100;
var y_0 = 300;
var player_radius = 50
var propulsion = 1200;
var engine_heat = 0;
var engine_cooling = 0.30;

var size_player;

var vX = 0;
var vY = 0;

var x_acc = 0;
var y_acc = 0;

var limit_angle = 1;
var robot_angle = 0;
var target_angle = 0;

// PLANET MARS
var x_mars = 200;
var y_mars = 300;
var r_mars = 100;

var mars;
var attraction_mars = 20000000;

// PLANET EARTH
var x_earth = 600;
var y_earth = 600;
var r_earth = 150;

var earth;
var attraction_earth = 40000000;

// PLANET WATER
var x_water = 1600;
var y_water = 350;
var r_water = 200;

var water;
var attraction_water = 30000000;

// BLACK HOLE
var x_bh = 1400;
var y_bh = 850;
var r_bh = 20;

var bh;
var attraction_bh = 50000000;

var sucked_by_bh;
    
var move_mode = 'fly';
var on_planet;
var double_gas_ready = false;

var propulsion_factor_mode_1 = 8;
    
var on_land = false;
var landing_done = false;

var cd_invulnerable = 0;
var invulnerable = false;

var game = new Phaser.Game(config);

var debug_inc = 0;
var target_angle_2;
var robot_angle_2;
var player_angle_2;

var iter = 0;

function preload ()
{
    this.load.image('space', 'assets/images/bg_space.jpg');
    this.load.image('mars_planet', 'assets/images/mars_planet_p.png');
    this.load.image('earth_planet', 'assets/images/earth_planet_p.png');
    this.load.image('water_planet', 'assets/images/water_planet_p.png');
    this.load.image('black_hole', 'assets/images/black_hole_p.png');
    this.load.image('bomb', 'assets/images/bomb.png');
    this.load.image('pick_up_hp', 'assets/images/star.png');
    this.load.image('dude', 'assets/images/perso_v0.png');
    this.load.image('flames', 'assets/images/flames_p.png');

    this.load.audio('engine', 'assets/audio/explosion.mp3');
}

function create ()
{
    hp_player = 100;
    robot_angle = 0;
    target_angle = 0;
    cd_helpText = 60;
    engine_heat = 0;
    move_mode = 'fly';
    double_gas_ready = false;
    gameOver = false;
    on_land = false;
    landing_done = false;
    cd_invulnerable = 0;
    invulnerable = false;
    size_player = 1;
    sucked_by_bh = false;
    
    space = this.add.tileSprite(0, 0, 12000, 12000, 'space');
    
    planets = this.physics.add.staticGroup();
    
    bombs = this.physics.add.staticGroup();
    
    for (theta = 0+200; theta<360+200; theta = theta + 360)
    {
        var bomb = bombs.create(x_mars + (r_mars-4) * Math.cos(2*Math.PI*theta/360), y_mars + (r_mars-4) * Math.sin(2*Math.PI*theta/360), 'bomb');
    }
    for (theta = 0+50; theta<360+50; theta = theta + 120)
    {
        var bomb = bombs.create(x_earth + (r_earth) * Math.cos(2*Math.PI*theta/360), y_earth + (r_earth) * Math.sin(2*Math.PI*theta/360), 'bomb');
    }
    for (theta = 0+40; theta<360+40; theta = theta + 60)
    {
        var bomb = bombs.create(x_water + (r_water+10) * Math.cos(2*Math.PI*theta/360), y_water + (r_water+10) * Math.sin(2*Math.PI*theta/360), 'bomb');
    }
    
    pick_up_hps = this.physics.add.staticGroup();
    
    for (theta = 0+140; theta<360+140; theta = theta + 160)
    {
        var pick_up_hp = pick_up_hps.create(x_mars + (r_mars+5) * Math.cos(2*Math.PI*theta/360), y_mars + (r_mars+5) * Math.sin(2*Math.PI*theta/360), 'pick_up_hp');
    }
    for (theta = 0+0; theta<360+0; theta = theta + 140)
    {
        var pick_up_hp = pick_up_hps.create(x_earth + (r_earth+10) * Math.cos(2*Math.PI*theta/360), y_earth + (r_earth+10) * Math.sin(2*Math.PI*theta/360), 'pick_up_hp');
    }
    for (theta = 0+90; theta<360+90; theta = theta + 120)
    {
        var pick_up_hp = pick_up_hps.create(x_water + (r_water+10) * Math.cos(2*Math.PI*theta/360), y_water + (r_water+10) * Math.sin(2*Math.PI*theta/360), 'pick_up_hp');
    }
    
    mars = planets.create(x_mars, y_mars, 'mars_planet');
    mars.setCircle(r_mars);
    
    earth = planets.create(x_earth, y_earth, 'earth_planet');
    earth.setCircle(r_earth);
    
    water = planets.create(x_water, y_water, 'water_planet');
    water.setCircle(r_water);
    
    this.add.image(x_bh, y_bh, 'black_hole');
    bh = planets.create(x_bh+180, y_bh+180, 'black_hole');
    bh.setVisible(false);
    bh.setCircle(r_bh);
    
    flames = this.add.image(x_0, y_0, 'flames');
    flames.setVisible(false);
    
    // The player and its settings
    player = this.physics.add.sprite(x_0, y_0, 'dude');

    //  Player physics properties.
    player.setCollideWorldBounds(true);
    
    player.setCircle(player_radius);

    //  Our player animations, turning, walking left and walking right.
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'dude', frame: 4 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'rotate',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });
    
    //  Input Events
    cursors = this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.Z, 'left': Phaser.Input.Keyboard.KeyCodes.Q, 'right': Phaser.Input.Keyboard.KeyCodes.D, 'down': Phaser.Input.Keyboard.KeyCodes.S,'gas': Phaser.Input.Keyboard.KeyCodes.SPACE, 'restart': Phaser.Input.Keyboard.KeyCodes.R, 'abandon': Phaser.Input.Keyboard.KeyCodes.A});
    
    // Indications diverses
    helpText = this.add.text(500, 600, "C'est parti !", style).setScrollFactor(0);
    deathText = this.add.text(400, 650, "", style).setScrollFactor(0);
    
    hpText = this.add.text(1100, 50, "Hp = 100", style).setScrollFactor(0);

    //  Collide the player and the stars with the platforms
    //this.physics.add.collider(player, earth, function(){move_mode = 'run'; on_land = true; on_planet = 'earth'; flames.setVisible(false)});
    //this.physics.add.collider(player, mars, function(){move_mode = 'run'; on_land = true; on_planet = 'mars'; flames.setVisible(false)});
    //this.physics.add.collider(player, water, function(){hp_reduction(); move_mode = 'run'; on_land = true; on_planet = 'water'; flames.setVisible(false)});
    //this.physics.add.collider(player, water, function(){hp_player -= 10; move_mode = 'run'; on_land = true; on_planet = 'water'; flames.setVisible(false)});
    //this.physics.add.collider(player, water, function(){move_mode = 'run'; on_land = true; on_planet = 'water'; flames.setVisible(false); helpText.setText("HP????"); if(Math.pow(Math.pow(vX_n0,2)+Math.pow(vY_n0,2),0.5) > 100){hp_player -= 10;}});
    this.physics.add.overlap(player, bombs, bomb_collision, null, this);
    this.physics.add.overlap(player, pick_up_hps, hp_collision, null, this);
    this.physics.add.collider(player, earth, earth_collision);
    this.physics.add.collider(player, mars, mars_collision);
    this.physics.add.collider(player, water, water_collision);
    //this.physics.add.collider(player, bh, function(){hp_player = 0; helpText.setText("Ce trou noir vous a absorb√© :O"); cd_helpText = 800});
    this.physics.add.collider(player, bh, bh_collision);
    
    // ********* SOUNDS *********
    
    //engine = this.add.audio('engine');
    engine = this.sound.add("engine", { loop: false });
    
    //this.sound.setDecodedCallback(engine, start, this);
    
    // ********* CAMERA *********
    
    this.physics.world.setBounds(-4000, -4000, 8000, 8000);
    
    //this.cameras.main.setBounds(0, 0, 1920 * 8, 1080 * 6);
    
    //this.cameras.main.setBounds(-8000, -8000, 5000, 5000);
    
    this.cameras.main.startFollow(player, true, 0.5, 0.5);
    
    // ********* GAMEPAD *********
    
    var text = this.add.text(10, 10, 'Press a button on the Gamepad to use', { font: '16px Courier', fill: '#00ff00' }).setScrollFactor(0);;

    this.input.gamepad.once('down', function (pad, button, index) {
        text.setText('Playing with ' + pad.id);
        gamepad = pad;
        for (const b of gamepad.buttons)
        {
            text.setText(helpText + b.index);
        }
    }, this);
    
    //game.input.gamepad.start();

    // To listen to buttons from a specific pad listen directly on that pad game.input.gamepad.padX, where X = pad 1-4
    //pad1 = this.input.gamepad.pad1;
    
    // ********* DEBUG *********
    
    if (config.physics.arcade.debug)
    {
        debugText = this.add.text(16, 16,"debug", {
            fontSize: '18px',
            padding: { x: 10, y: 5 },
            backgroundColor: '#000000',
            fill: '#ffffff'
        });
        debugText.setScrollFactor(0);
    }
}

function update ()
{
    this.input.gamepad.once('connected', function (pad) {
        // 'pad' is a reference to the gamepad that was just connected
    });
    
    gamepad?gamepadA=gamepad.A:gamepadA=false;
    gamepad?gamepadL=(gamepad.leftStick.x<-0.5?true:false):gamepadL=false;
    gamepad?gamepadR=(gamepad.leftStick.x>+0.5?true:false):gamepadR=false;
    //if(gamepad){gamepadA = gamepad.A;}else{gamepadA =false;}
    //if(gamepad){gamepadL = ();}else{gamepadA =false;}
    //if(gamepad){gamepadA = gamepad.A;}else{gamepadA =false;}
    
    vX = player.body.velocity.x;
    vY = player.body.velocity.y;
    
    hpText.setText('Hp = ' + hp_player);
    
    space.tilePositionX = Math.cos(iter) * 2000;
    space.tilePositionY = Math.sin(iter) * 200;
    
    iter += 0.0002;
    
    if (hp_player <= 0){gameOver=true;}
    
    if (cursors.restart.isDown)// || gamepad.Start)
    {
        this.registry.destroy(); // destroy registry
        this.events.off(); // disable all active events
        this.scene.restart(); // restart current scene
    }
    
    if (cursors.abandon.isDown)
    {
        this.registry.destroy(); // destroy registry
        this.events.off(); // disable all active events
        this.scene.stop(); // restart current scene
    }
    
    if (gameOver)
    {
        this.physics.pause();
        player.setTint(0x00f040);
        deathText.setText("Relancer (r) ou abandonner (a) ?");
        cd_helpText = 60000;
        //flames.setVisible(false)
        //player.destroy();
        //return;
    }
    else
    {
        if (move_mode == 'fly')
        {
            // Le joueur est attir√© par toutes les plan√®tes
            x_acc = -attraction_mars*(player.x-x_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
            x_acc += -attraction_earth*(player.x-x_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
            x_acc += -attraction_water*(player.x-x_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
            x_acc += -attraction_bh*(player.x-x_bh)/Math.pow((Math.pow(player.x-x_bh,2)+Math.pow(player.y-y_bh,2)),1.5);
            y_acc = -attraction_mars*(player.y-y_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
            y_acc += -attraction_earth*(player.y-y_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
            y_acc += -attraction_water*(player.y-y_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
            y_acc += -attraction_bh*(player.y-y_bh)/Math.pow((Math.pow(player.x-x_bh,2)+Math.pow(player.y-y_bh,2)),1.5);
            
            x_acc += +6*attraction_mars*(player.x+4000)/Math.pow(Math.pow(player.x+4000,2),1.5);
            y_acc += +6*attraction_mars*(player.y+4000)/Math.pow(Math.pow(player.y+4000,2),1.5);
            x_acc += +6*attraction_mars*(player.x-4000)/Math.pow(Math.pow(player.x-4000,2),1.5);
            y_acc += +6*attraction_mars*(player.y-4000)/Math.pow(Math.pow(player.y-4000,2),1.5);

            if (gamepad)
            {
                if (Math.pow(gamepad.leftStick.x,2)+Math.pow(gamepad.leftStick.y,2)>0.95)
                {
                    if (gamepad.leftStick.x == 0){target_angle = 0;}
                    else
                    {
                        target_angle = Math.round(360*Math.atan2(-gamepad.leftStick.y,gamepad.leftStick.x)/(2*Math.PI));
                        if (target_angle < 0){target_angle += 360;}
                    }
                }
            }

            //D√©finition de la direction souhait√©e du joueur :
            if (cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
            {
                target_angle = 180;
            }
            else if (!cursors.left.isDown && cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
            {
                target_angle = 90;
            }    
            else if (!cursors.left.isDown && !cursors.up.isDown && cursors.right.isDown && !cursors.down.isDown)
            {
                target_angle = 0;
            }   
            else if (!cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && cursors.down.isDown)
            {
                target_angle = 270;
            }
            else if (cursors.left.isDown && cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
            {
                target_angle = 135;
            }
            else if (!cursors.left.isDown && cursors.up.isDown && cursors.right.isDown && !cursors.down.isDown)
            {
                target_angle = 45;
            }
            else if (!cursors.left.isDown && !cursors.up.isDown && cursors.right.isDown && cursors.down.isDown)
            {
                target_angle = 315;
            }
            else if (cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && cursors.down.isDown)
            {
                target_angle = 225;
            }
            
            // Gestion de la rotation du joueur pour atteindre la direction souhait√©e :
            // on tourne le joueur jusqu'√† l'atteindre en utilisant le sens de rotation qui minimise la dur√©e de rotation.
            if (Math.abs(target_angle - robot_angle) > limit_angle)
            {
                if (((0 <= target_angle - robot_angle) && (target_angle - robot_angle < 180)) || target_angle - robot_angle < -180)
                {
                    //player.anims.play('right', true);
                    robot_angle += 2.5;
                    if (robot_angle >= 360)
                    {
                        robot_angle -= 360
                    }
                    player.angle -= 2.5;
                }
                else
                {
                    //player.anims.play('left', true);
                    robot_angle -= 2.5;
                    if (robot_angle < 0)
                    {
                        robot_angle += 360
                    }
                    player.angle += 2.5;
                }
            }
            
            /*if (gamepad)
            {
                /*this.input.gamepad.button.children.each(function(butt){
                        player.angle += 2.5;//console.log(butt);
                },this);
                
                /*this.gamepad.on('down', (pad, button, value) =>{
                    console.log(button.index);          
                });
                
                if (gamepad.A)
                {
                    // Le moteur ne peut √™tre utilis√© que s'il n'est pas en surchauffe
                    if (engine_heat < 80)
                    {
                        // On modifie l'acc√©l√©ration √† chaque frame en fonction de sa direction de propulsion et de sa position par rapport
                        // aux diff√©rents astres attracteurs et objets r√©pulseurs en utilisant des forces de type (Constante/Distance^2)
                        x_acc += propulsion * Math.cos(2*Math.PI*robot_angle/360);
                        y_acc += - propulsion * Math.sin(2*Math.PI*robot_angle/360);
                        // Le moteur se r√©chauffe lorsqu'il est utilis√©, et il √©met un son
                        engine_heat += 1;
                        flames.x = player.x - 75*Math.cos(2*Math.PI*player.angle/360);
                        flames.y = player.y - 75*Math.sin(2*Math.PI*player.angle/360);
                        flames.angle = player.angle - 90;
                        flames.setVisible(true);
                        engine.play();
                    }
                    else
                    {
                        helpText.setText("Moteur en surchauffe !");
                        flames.setVisible(false);
                        cd_helpText = 80;
                    }
                }
                else
                {
                    // Le moteur se refroidit lorsqu'il n'est pas utilis√©
                    flames.setVisible(false);
                    engine_heat = Math.max(0, engine_heat - engine_cooling);
                }

                /*if (gamepad.up)
                {
                    sprite.y -= 4;
                }
                else if (gamepad.down)
                {
                    sprite.y += 4;
                }
            }
            else */
            
            if (cursors.gas.isDown || gamepadA)
            {
                // Le moteur ne peut √™tre utilis√© que s'il n'est pas en surchauffe
                if (engine_heat < 80)
                {
                    // On modifie l'acc√©l√©ration √† chaque frame en fonction de sa direction de propulsion et de sa position par rapport
                    // aux diff√©rents astres attracteurs et objets r√©pulseurs en utilisant des forces de type (Constante/Distance^2)
                    x_acc += propulsion * Math.cos(2*Math.PI*robot_angle/360);
                    y_acc += - propulsion * Math.sin(2*Math.PI*robot_angle/360);
                    // Le moteur se r√©chauffe lorsqu'il est utilis√©, et il √©met un son
                    engine_heat += 1;
                    flames.x = player.x - 75*Math.cos(2*Math.PI*player.angle/360);
                    flames.y = player.y - 75*Math.sin(2*Math.PI*player.angle/360);
                    flames.angle = player.angle - 90;
                    flames.setVisible(true);
                    engine.play();
                }
                else
                {
                    helpText.setText("Moteur en surchauffe !");
                    flames.setVisible(false);
                    cd_helpText = 80;
                }
            }
            else
            {
                // Le moteur se refroidit lorsqu'il n'est pas utilis√©
                flames.setVisible(false);
                engine_heat = Math.max(0, engine_heat - engine_cooling);
            }
        }
        else if (move_mode == 'run')
        {
            if (on_planet == 'earth')
            {
                x_acc = -attraction_earth*(player.x-x_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
                y_acc = -attraction_earth*(player.y-y_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
                var difX = player.x - x_earth;
                var difY = player.y - y_earth;
            }
            else if (on_planet == 'mars')
            {
                x_acc = -attraction_mars*(player.x-x_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
                y_acc = -attraction_mars*(player.y-y_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
                var difX = player.x - x_mars;
                var difY = player.y - y_mars;
            }
            else if (on_planet == 'water')
            {
                x_acc = -attraction_water*(player.x-x_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
                y_acc = -attraction_water*(player.y-y_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
                var difX = player.x - x_water;
                var difY = player.y - y_water;
            }

            if ( Math.abs(difX) < 0.1 && difY > 0)
            {
                target_angle = 90;
            }
            else if ( Math.abs(difX) < 0.1 && difY < 0)
            {
                target_angle = 270;
            }
            else if ( Math.abs(difY) < 0.1 && difX > 0)
            {
                target_angle = 0;
            }
            else if ( Math.abs(difY) < 0.1 && difX < 0)
            {
                target_angle = 180;
            }
            else if (difX > 0 && difY > 0)
            {
                target_angle = 360 - 360*Math.atan(difY/difX)/(2*Math.PI);
            }
            else if (difX > 0 && difY < 0)
            {
                target_angle = - 360*Math.atan(difY/difX)/(2*Math.PI);
            }
            else
            {
                target_angle = 180 - 360*Math.atan(difY/difX)/(2*Math.PI);
            }

            if (Math.abs(target_angle - robot_angle) > limit_angle)
            {
                if (((0 <= target_angle - robot_angle) && (target_angle - robot_angle < 180)) || target_angle - robot_angle < -180)
                {
                    //player.anims.play('right', true);
                    robot_angle += 1.25;
                    if (robot_angle >= 360)
                    {
                        robot_angle -= 360
                    }
                    player.angle -= 1.25;
                }
                else
                {
                    //player.anims.play('left', true);
                    robot_angle -= 1.25;
                    if (robot_angle < 0)
                    {
                        robot_angle += 360
                    }
                    player.angle += 1.25;
                }
            }
            else
            {
                landing_done = true;
                engine_heat = Math.max(0, engine_heat - 20);
            }

            if ((cursors.left.isDown || gamepadL) && on_land && landing_done)
            {
                /*if (on_obstacle)
                {
                    x_acc += 500*Math.cos(2*Math.PI*(player.angle-90)/360);
                    y_acc += 500*Math.sin(2*Math.PI*(player.angle-90)/360);                    
                }
                else
                {*/
                x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*(player.angle-90)/360);
                y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*(player.angle-90)/360);

            }
            else if ((cursors.right.isDown || gamepadR) && on_land && landing_done)
            {
                x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*(player.angle+90)/360);
                y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*(player.angle+90)/360);
            }

            if ((cursors.gas.isDown || gamepadA) && on_land && landing_done)
            {
                x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*player.angle/360);
                y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*player.angle/360);
                on_land = false;
                double_gas_ready = false;
            }
            else if (!cursors.gas.isDown && !gamepadA)
            {
                double_gas_ready = true;
            }
            else if ((cursors.gas.isDown || gamepadA) && !on_land && double_gas_ready)
            {
                x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*player.angle/360);
                y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*player.angle/360);
                move_mode = 'fly';
                landing_done = false;
                robot_angle = -player.angle;
                target_angle = -player.angle;
            }
        }

        player.setAccelerationX(x_acc);
        player.setAccelerationY(y_acc);

        /*
        if (player.x >= config.height + player_radius)
        {
            player.x = 0;
        }
        else if (player.x <= 0 + player_radius)
        {
            player.x = config.height;
        }

        if (player.y >= config.width + player_radius)
        {
            player.y = 0;
        }
        else if (player.y <= 0 + player_radius)
        {
            player.y = config.width;
        }
        */

        if (cd_invulnerable == 0)
        {
            invulnerable = false;
        }
        else
        {
            cd_invulnerable -= 1;
        }
        
        // Gestion de la disparition du texte d'aide
        if (cd_helpText == 0)
        {
            helpText.setText("");
        }
        else
        {
            cd_helpText -= 1;
        }

        if (config.physics.arcade.debug)
        {
            // Section debug
            if (debug_inc == 0)
            {
                debug_inc = 1;
                target_angle_2 = target_angle;
                robot_angle_2 = robot_angle;
                player_angle_2 = player.angle;
            }
            else
            {
                debug_inc = 0;
                debugText.setText('target_angle : ' + target_angle + '  ***  target_angle_2 : ' + target_angle_2 +
                '\n robot_angle : ' + robot_angle + '  ***  robot_angle_2 : ' + robot_angle_2 +
                '\n player.angle : ' + player.angle + '  ***  player.angle_2 : ' + player_angle_2 +
                '\n player.Vx : ' + 50*Math.round(player.body.velocity.x/50) + '  ***  player.Vy : ' + 50*Math.round(player.body.velocity.y/50) +
                //'\n Velocity : ' + 100*Math.round(Math.pow(Math.pow(player.body.velocity.x,2)+Math.pow(player.body.velocity.y,2),0.5)/100) +
                '\n Velocity : ' + Math.pow(Math.pow(vX,2)+Math.pow(vY,2),0.5) +
                '\n Angle : ' + Math.pow(Math.pow(vX,2)+Math.pow(vY,2),0.5) +
                '\n on planet : ' + on_planet);
            }
        }
    }
}

function hp_collision(player, pick_up_hp)
{
    pick_up_hp.disableBody(true, true);
    hp_player += 20;
}
    
function bomb_collision()
{
    if (!invulnerable)
    {
        hp_player -= 10;
        if (hp_player <= 0)
        {
            helpText.setText("Pense √† arr√™ter de marcher dans les piques : /");
            cd_helpText = 800;
        }
        invulnerable = true;
        cd_invulnerable = 180;
    }
}
    
function earth_collision()
{
    var difX = player.x - x_earth;
    var difY = player.y - y_earth;

    if (Math.abs(difX) < 0.1 && difY > 0)
    {
        target_angle = 90;
    }
    else if (Math.abs(difX) < 0.1 && difY < 0)
    {
        target_angle = 270;
    }
    else if (Math.abs(difY) < 0.1 && difX > 0)
    {
        target_angle = 0;
    }
    else if (Math.abs(difY) < 0.1 && difX < 0)
    {
        target_angle = 180;
    }
    else if (difX > 0 && difY > 0)
    {
        target_angle = 360 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else if (difX > 0 && difY < 0)
    {
        target_angle = - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else
    {
        target_angle = 180 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    move_mode = 'run';
    on_land = true;
    on_planet = 'earth';
    flames.setVisible(false);
    hp_player -= Math.max(2*(Math.round(Math.abs(Math.sin(Math.PI*(target_angle - robot_angle)/360))*Math.pow(Math.pow(vX,2)+Math.pow(vY,2),0.5)/10)-3),0);
    if (hp_player <= 0)
    {
        helpText.setText("Un atterrisage pourri de trop : /");
        cd_helpText = 800;
    }
}

function mars_collision()
{
    var difX = player.x - x_mars;
    var difY = player.y - y_mars;

    if (Math.abs(difX) < 0.1 && difY > 0)
    {
        target_angle = 90;
    }
    else if (Math.abs(difX) < 0.1 && difY < 0)
    {
        target_angle = 270;
    }
    else if (Math.abs(difY) < 0.1 && difX > 0)
    {
        target_angle = 0;
    }
    else if (Math.abs(difY) < 0.1 && difX < 0)
    {
        target_angle = 180;
    }
    else if (difX > 0 && difY > 0)
    {
        target_angle = 360 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else if (difX > 0 && difY < 0)
    {
        target_angle = - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else
    {
        target_angle = 180 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    move_mode = 'run';
    on_land = true;
    on_planet = 'mars';
    flames.setVisible(false);
    hp_player -= Math.max(2*(Math.round(Math.abs(Math.sin(Math.PI*(target_angle - robot_angle)/360))*Math.pow(Math.pow(vX,2)+Math.pow(vY,2),0.5)/10)-3),0);
    if (hp_player <= 0)
    {
        helpText.setText("Un atterrisage pourri de trop : /");
        cd_helpText = 800;
    }
}

function water_collision()
{
    var difX = player.x - x_water;
    var difY = player.y - y_water;

    if (Math.abs(difX) < 0.1 && difY > 0)
    {
        target_angle = 90;
    }
    else if (Math.abs(difX) < 0.1 && difY < 0)
    {
        target_angle = 270;
    }
    else if (Math.abs(difY) < 0.1 && difX > 0)
    {
        target_angle = 0;
    }
    else if (Math.abs(difY) < 0.1 && difX < 0)
    {
        target_angle = 180;
    }
    else if (difX > 0 && difY > 0)
    {
        target_angle = 360 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else if (difX > 0 && difY < 0)
    {
        target_angle = - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    else
    {
        target_angle = 180 - 360*Math.atan(difY/difX)/(2*Math.PI);
    }
    move_mode = 'run';
    on_land = true;
    on_planet = 'water';
    flames.setVisible(false);
    hp_player -= Math.max(2*(Math.round(Math.abs(Math.sin(Math.PI*(target_angle - robot_angle)/360))*Math.pow(Math.pow(vX,2)+Math.pow(vY,2),0.5)/10)-3),0);
    if (hp_player <= 0)
    {
        helpText.setText("Un atterrisage pourri de trop : /");
        cd_helpText = 800;
    }
}

function bh_collision()
{
    sucked_by_bh = true;
    if (size_player <= 0.01)
    {
        hp_player = 0;
        helpText.setText("Ce trou noir vous a absorb√© :O");
        cd_helpText = 800;
    }
    else
    {
        size_player -= 0.01;
        attraction_bh *= 0.9;
        player.setScale(size_player);
    }
}

</script>

</body>
</html>