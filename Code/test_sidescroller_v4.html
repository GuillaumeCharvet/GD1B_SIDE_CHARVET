<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 10</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    width: 4000,
    height: 2000,
    physics: {
        default: 'arcade',
        arcade: {
            //gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var style = { font: "40px Arial", fill: "#52bace", align: "center" };
var cd_helpText = 60;

var player;
/*var stars;
var bombs;
var platforms;*/
var cursors;
//var score = 0;
var gameOver = false;
//var scoreText;
//var doubleJumpPossible = true;
//var sautGauche = false;
//var sautDroit = false;

var propulsion = 1000;
var engine_heat = 0;
var engine_cooling = 0.15;
    
var x_acc = 0;
var y_acc = 0;

var limit_angle = 1;
var robot_angle = 0;
var target_angle = 0;

// PLANET MARS
var x_mars = 200;
var y_mars = 300;

var mars;
var attraction_mars = 10000000;

// PLANET EARTH
var x_earth = 600;
var y_earth = 600;

var earth;
var attraction_earth = 20000000;

// PLANET WATER
var x_water = 1600;
var y_water = 350;

var water;
var attraction_water = 15000000;

// BLACK HOLE
var x_bh = 1400;
var y_bh = 850;

var bh;
var attraction_bh = 40000000;

var move_mode = 0;
var on_planet;
var double_gas_ready = false;

var propulsion_factor_mode_1 = 8;
    
var on_land = false;
var landing_done = false;

var game = new Phaser.Game(config);

var debug_inc = 0;
var target_angle_2;
var robot_angle_2;
var player_angle_2;

var iter = 0;
    
function preload ()
{
    
    //this.load.image('sky', 'assets/images/sky.png');
    this.load.image('space', 'assets/images/bg_space.jpg');
    //this.load.image('ground', 'assets/images/platform.png');
    //this.load.image('star', 'assets/images/star.png');
    //this.load.image('bomb', 'assets/images/bomb.png');
    this.load.image('mars_planet', 'assets/images/mars_planet_p.png');
    this.load.image('earth_planet', 'assets/images/earth_planet_p.png');
    this.load.image('water_planet', 'assets/images/water_planet_p.png');
    this.load.image('black_hole', 'assets/images/black_hole_p.png');
    //this.load.spritesheet('dude', 'assets/images/dude.png', { frameWidth: 32, frameHeight: 48 });
    this.load.image('dude', 'assets/images/perso_v0.png');
    
    //this.load.audio('engine', 'assets/audio/spaceEngineLarge_002.ogg');
    this.load.audio('engine', 'assets/audio/explosion.mp3');
}

function create ()
{
    //  A simple background for our game
    //this.add.image(400, 300, 'sky');
    //this.add.image(400, 300, 'space').setScale(1.5);
    space = this.add.tileSprite(0, 0, 4000, 2000, 'space');

    //  The platforms group contains the ground and the 2 ledges we can jump on
    //platforms = this.physics.add.staticGroup();

    //  Here we create the ground.
    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    //platforms.create(400, 568, 'ground').setScale(2).refreshBody();

    //  Now let's create some ledges
    //platforms.create(600, 400, 'ground');

    //mars = this.physics.add.sprite(x_mars, y_mars, 'mars_planet').setScale(0.3);
    
    /*mars = this.physics.add.staticGroup();
    mars.create(x_mars, y_mars, 'mars_planet').setScale(0.4);*/
    
    planets = this.physics.add.staticGroup();
    
    mars = planets.create(x_mars, y_mars, 'mars_planet');
    mars.setCircle(100);
    
    earth = planets.create(x_earth, y_earth, 'earth_planet');
    earth.setCircle(150);
    
    water = planets.create(x_water, y_water, 'water_planet');
    water.setCircle(200);
    
    this.add.image(x_bh, y_bh, 'black_hole');
    bh = planets.create(x_bh+160, y_bh+160, 'black_hole');
    bh.setVisible(false);
    bh.setCircle(40);
    
    //mars = this.physics.add.image(x_mars, y_mars, 'mars_planet');
    //mars.setCircle(100);
    
    // The player and its settings
    player = this.physics.add.sprite(1100, 300, 'dude');

    //  Player physics properties. Give the little guy a slight bounce.
    //player.setBounce(0.2);
    player.setCollideWorldBounds(true);
    
    player.setCircle(50);

    //  Our player animations, turning, walking left and walking right.
    this.anims.create({
        key: 'left',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'turn',
        frames: [ { key: 'dude', frame: 4 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'right',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'rotate',
        frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
        frameRate: 10,
        repeat: -1
    });
    
    
    //  Input Events
    //cursors = this.input.keyboard.createCursorKeys();
    
    cursors = this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.Z, 'left': Phaser.Input.Keyboard.KeyCodes.Q, 'right': Phaser.Input.Keyboard.KeyCodes.D, 'down': Phaser.Input.Keyboard.KeyCodes.S,'gas': Phaser.Input.Keyboard.KeyCodes.SPACE});
    
    
    //  Some stars to collect, 12 in total, evenly spaced 70 pixels apart along the x axis
    /*stars = this.physics.add.group({
        key: 'star',
        repeat: 11,
        setXY: { x: 12, y: 0, stepX: 70 }
    });*/

    /*stars.children.iterate(function (child) {

        //  Give each star a slightly different bounce
        child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));

    });*/

    //bombs = this.physics.add.group();

    //  The score
    //scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
    
    // Indications diverses
    //helpText = this.add.text(280, 542, "C'est parti", { fontSize: '32px', fill: '#000' });
    helpText = this.add.text(800, 800, "C'est parti !", style);

    //  Collide the player and the stars with the platforms
    /*this.physics.add.collider(player, platforms, doubleJumpReset, null, this);
    this.physics.add.collider(stars, platforms);
    this.physics.add.collider(bombs, platforms);*/
    //this.physics.add.collider(player, obstacles, function(){move_mode = 1; on_land = true; on_planet = 'earth'});
    this.physics.add.collider(player, earth, function(){move_mode = 1; on_land = true; on_planet = 'earth'});
    this.physics.add.collider(player, mars, function(){move_mode = 1; on_land = true; on_planet = 'mars'});
    this.physics.add.collider(player, water, function(){move_mode = 1; on_land = true; on_planet = 'water'});
    this.physics.add.collider(player, bh, function(){gameOver = true; helpText.setText("Ce trou noir vous a absorbé :O"); cd_helpText = 800;});

    //  Checks to see if the player overlaps with any of the stars, if he does call the collectStar function
    //this.physics.add.overlap(player, stars, collectStar, null, this);

    //this.physics.add.collider(player, bombs, hitBomb, null, this);
    
    //up = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.UP);
    
    // ********* SOUNDS *********
    
    //engine = this.add.audio('engine');
    engine = this.sound.add("engine", { loop: false });
    
    //this.sound.setDecodedCallback(engine, start, this);
    
    //this.cameras.main.setBounds(0, 0, 4000, 2000);
    //this.cameras.main.startFollow(player, true, 0.5, 0.5);
    
    if (config.physics.arcade.debug)
    {
        debugText = this.add.text(16, 16,"debug", {
            fontSize: '18px',
            padding: { x: 10, y: 5 },
            backgroundColor: '#000000',
            fill: '#ffffff'
        });
        debugText.setScrollFactor(0);
    }
    
}

function update ()
{
    space.tilePositionX = Math.cos(iter) * 2000;
    space.tilePositionY = Math.sin(iter) * 200;
    
    iter += 0.0002;
    
    if (gameOver)
    {
        player.destroy();
        return;
    }
    
    if (move_mode == 0)
    {
        // Le joueur est attiré par toutes les planètes 
        x_acc = -attraction_mars*(player.x-x_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
        x_acc += -attraction_earth*(player.x-x_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
        x_acc += -attraction_water*(player.x-x_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
        x_acc += -attraction_bh*(player.x-x_bh)/Math.pow((Math.pow(player.x-x_bh,2)+Math.pow(player.y-y_bh,2)),1.5);
        y_acc = -attraction_mars*(player.y-y_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
        y_acc += -attraction_earth*(player.y-y_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
        y_acc += -attraction_water*(player.y-y_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
        y_acc += -attraction_bh*(player.y-y_bh)/Math.pow((Math.pow(player.x-x_bh,2)+Math.pow(player.y-y_bh,2)),1.5);
        
        //Définition de la direction souhaitée du joueur :
        if (cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
        {
            target_angle = 180;
        }
        else if (!cursors.left.isDown && cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
        {
            target_angle = 90;
        }    
        else if (!cursors.left.isDown && !cursors.up.isDown && cursors.right.isDown && !cursors.down.isDown)
        {
            target_angle = 0;
        }   
        else if (!cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && cursors.down.isDown)
        {
            target_angle = 270;
        }
        else if (cursors.left.isDown && cursors.up.isDown && !cursors.right.isDown && !cursors.down.isDown)
        {
            target_angle = 135;
        }
        else if (!cursors.left.isDown && cursors.up.isDown && cursors.right.isDown && !cursors.down.isDown)
        {
            target_angle = 45;
        }
        else if (!cursors.left.isDown && !cursors.up.isDown && cursors.right.isDown && cursors.down.isDown)
        {
            target_angle = 315;
        }
        else if (cursors.left.isDown && !cursors.up.isDown && !cursors.right.isDown && cursors.down.isDown)
        {
            target_angle = 225;
        }

        // Gestion de la rotation du joueur pour atteindre la direction souhaitée :
        // on tourne le joueur jusqu'à l'atteindre en utilisant le sens de rotation qui minimise la durée de rotation.
        if (Math.abs(target_angle - robot_angle) > limit_angle)
        {
            if (((0 <= target_angle - robot_angle) && (target_angle - robot_angle < 180)) || target_angle - robot_angle < -180)
            {
                //player.anims.play('right', true);
                robot_angle += 2.5;
                if (robot_angle >= 360)
                {
                    robot_angle -= 360
                }
                player.angle -= 2.5;
            }
            else
            {
                //player.anims.play('left', true);
                robot_angle -= 2.5;
                if (robot_angle < 0)
                {
                    robot_angle += 360
                }
                player.angle += 2.5;
            }
        }
        /*else
        {
            //player.anims.play('turn', true);
        }*/

        if (cursors.gas.isDown)
        {
            // Le moteur ne peut être utilisé que s'il n'est pas en surchauffe
            if (engine_heat < 80)
            {
                // On modifie l'accélération à chaque frame en fonction de sa direction de propulsion et de sa position par rapport
                // aux différents astres attracteurs et objets répulseurs en utilisant des forces de type (Constante/Distance^2)
                x_acc += propulsion * Math.cos(2*Math.PI*robot_angle/360);
                y_acc += - propulsion * Math.sin(2*Math.PI*robot_angle/360);
                // Le moteur se réchauffe lorsqu'il est utilisé, et il émet un son
                engine_heat += 1;
                engine.play();
            }
            else
            {
                helpText.setText("Moteur en surchauffe !");
                cd_helpText = 80;
            }
        }
        else
        {
            // Le moteur se refroidit lorsqu'il n'est pas utilisé
            engine_heat = Math.max(0, engine_heat - engine_cooling);
        }
    }
    else if (move_mode == 1)
    {
        /*switch (on_planet)
        {
            case 'earth':
                x_acc = -attraction_earth*(player.x-x_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
                y_acc = -attraction_earth*(player.y-y_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
                var difX = player.x - x_earth;
                var difY = player.y - y_earth;
            case 'mars':
                x_acc = -attraction_mars*(player.x-x_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
                y_acc = -attraction_mars*(player.y-y_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
                var difX = player.x - x_mars;
                var difY = player.y - y_mars;
        }*/
        if (on_planet == 'earth')
        {
            x_acc = -attraction_earth*(player.x-x_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
            y_acc = -attraction_earth*(player.y-y_earth)/Math.pow((Math.pow(player.x-x_earth,2)+Math.pow(player.y-y_earth,2)),1.5);
            var difX = player.x - x_earth;
            var difY = player.y - y_earth;
        }
        else if (on_planet == 'mars')
        {
            x_acc = -attraction_mars*(player.x-x_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
            y_acc = -attraction_mars*(player.y-y_mars)/Math.pow((Math.pow(player.x-x_mars,2)+Math.pow(player.y-y_mars,2)),1.5);
            var difX = player.x - x_mars;
            var difY = player.y - y_mars;
        }
        else if (on_planet == 'water')
        {
            x_acc = -attraction_water*(player.x-x_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
            y_acc = -attraction_water*(player.y-y_water)/Math.pow((Math.pow(player.x-x_water,2)+Math.pow(player.y-y_water,2)),1.5);
            var difX = player.x - x_water;
            var difY = player.y - y_water;
        }
        
        if ( Math.abs(difX) < 0.1 && difY > 0)
        {
            target_angle = 90;
        }
        else if ( Math.abs(difX) < 0.1 && difY < 0)
        {
            target_angle = 270;
        }
        else if ( Math.abs(difY) < 0.1 && difX > 0)
        {
            target_angle = 0;
        }
        else if ( Math.abs(difY) < 0.1 && difX < 0)
        {
            target_angle = 180;
        }
        else if (difX > 0 && difY > 0)
        {
            target_angle = 360 - 360*Math.atan(difY/difX)/(2*Math.PI);
        }
        else if (difX > 0 && difY < 0)
        {
            target_angle = - 360*Math.atan(difY/difX)/(2*Math.PI);
        }
        else
        {
            target_angle = 180 - 360*Math.atan(difY/difX)/(2*Math.PI);
        }
        
        if (Math.abs(target_angle - robot_angle) > limit_angle)
        {
            if (((0 <= target_angle - robot_angle) && (target_angle - robot_angle < 180)) || target_angle - robot_angle < -180)
            {
                //player.anims.play('right', true);
                robot_angle += 1.25;
                if (robot_angle >= 360)
                {
                    robot_angle -= 360
                }
                player.angle -= 1.25;
            }
            else
            {
                //player.anims.play('left', true);
                robot_angle -= 1.25;
                if (robot_angle < 0)
                {
                    robot_angle += 360
                }
                player.angle += 1.25;
            }
        }
        else
        {
            landing_done = true;
            engine_heat = Math.max(0, engine_heat - 20);
        }
        
        if (cursors.left.isDown && on_land && landing_done)
        {
            /*if (on_obstacle)
            {
                x_acc += 500*Math.cos(2*Math.PI*(player.angle-90)/360);
                y_acc += 500*Math.sin(2*Math.PI*(player.angle-90)/360);                    
            }
            else
            {*/
            x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*(player.angle-90)/360);
            y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*(player.angle-90)/360);
            
        }
        else if (cursors.right.isDown && on_land && landing_done)
        {
            x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*(player.angle+90)/360);
            y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*(player.angle+90)/360);
        }
        
        if (cursors.gas.isDown && on_land && landing_done)
        {
            x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*player.angle/360);
            y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*player.angle/360);
            on_land = false;
            double_gas_ready = false;
        }
        else if (!cursors.gas.isDown)
        {
            double_gas_ready = true;
        }
        else if (cursors.gas.isDown && !on_land && double_gas_ready)
        {
            x_acc += propulsion_factor_mode_1*propulsion*Math.cos(2*Math.PI*player.angle/360);
            y_acc += propulsion_factor_mode_1*propulsion*Math.sin(2*Math.PI*player.angle/360);
            move_mode = 0;
            landing_done = false;
            robot_angle = -player.angle;
            target_angle = -player.angle;
        }
        
    }
    
    player.setAccelerationX(x_acc);
    player.setAccelerationY(y_acc);
    
    // Gestion de la disparition du texte d'aide
    if (cd_helpText == 0)
    {
        helpText.setText("");
    }
    else
    {
        cd_helpText -= 1;
    }
    
    if (config.physics.arcade.debug)
    {
        // Section debug
        if (debug_inc == 0)
        {
            debug_inc = 1;
            target_angle_2 = target_angle;
            robot_angle_2 = robot_angle;
            player_angle_2 = player.angle;
        }
        else
        {
            debug_inc = 0;
            debugText.setText('target_angle : ' + target_angle + ' - target_angle_2 : ' + target_angle_2 +
            '\n robot_angle : ' + robot_angle + ' - robot_angle_2 : ' + robot_angle_2 +
            '\n player.angle : ' + player.angle + ' - player.angle_2 : ' + player_angle_2);
        }
    }
    
}

/*function doubleJumpReset (player, platform)//, doubleJumpPossible)
{
    if (player.body.touching.down)
    {   
        doubleJumpPossible = true;
    }
}

function collectStar (player, star)
{
    star.disableBody(true, true);

    //  Add and update the score
    score += 10;
    scoreText.setText('Score: ' + score);

    if (stars.countActive(true) === 0)
    {
        //  A new batch of stars to collect
        stars.children.iterate(function (child) {

            child.enableBody(true, child.x, 0, true, true);

        });

        var x = (player.x < 400) ? Phaser.Math.Between(400, 800) : Phaser.Math.Between(0, 400);

        var bomb = bombs.create(x, 16, 'bomb');
        bomb.setBounce(1);
        bomb.setCollideWorldBounds(true);
        bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);
        bomb.allowGravity = false;

    }
}

function hitBomb (player, bomb)
{
    this.physics.pause();

    player.setTint(0xff0000);

    player.anims.play('turn');

    gameOver = true;
}*/

</script>

</body>
</html>